import {IModel, Model} from 'mobx-collection-store';

import IDictionary from './interfaces/IDictionary';
import IJsonApiOptions from './interfaces/IJsonApiOptions';
import IRequestOptions from './interfaces/IRequestOptions';
import * as JsonApi from './interfaces/JsonApi';

import {
  buildRelationshipUrl,
  buildUrl,
  create,
  fetchLink,
  handleResponse,
  remove,
  update,
} from './NetworkUtils';
import {Response} from './Response';
import {Store} from './Store';
import {getValue, mapItems, objectForEach} from './utils';

interface IInternal {
  relationships?: IDictionary<JsonApi.IRelationship>;
  meta?: object;
  links?: IDictionary<JsonApi.ILink>;
  persisted?: boolean;
  id: number|string;
  type: string;
}

export class Record extends Model implements IModel {

  /**
   * Type property of the record class
   *
   * @static
   *
   * @memberOf Record
   */
  public static typeAttribute = ['__internal', 'type'];

  /**
   * ID property of the record class
   *
   * @static
   *
   * @memberOf Record
   */
  public static idAttribute = ['__internal', 'id'];

  /**
   * Should the autogenerated ID be sent to the server when creating a record
   *
   * @static
   * @type {boolean}
   * @memberOf Record
   */
  public static useAutogeneratedIds: boolean = false;

  /**
   * Endpoint for API requests if there is no self link
   *
   * @static
   * @type {string|() => string}
   * @memberOf Record
   */
  public static endpoint: string|(() => string);

  public 'static': typeof Record;

  /**
   * Internal metadata
   *
   * @private
   * @type {IInternal}
   * @memberOf Record
   */
  private __internal: IInternal;

  /**
   * Cache link fetch requests
   *
   * @private
   * @type {IDictionary<Promise<Response>>}
   * @memberOf Record
   */
  private __relationshipLinkCache: IDictionary<IDictionary<Promise<Response>>> = {};

  /**
   * Cache link fetch requests
   *
   * @private
   * @type {IDictionary<Promise<Response>>}
   * @memberOf Record
   */
  private __linkCache: IDictionary<Promise<Response>> = {};

  /**
   * Get record relationship links
   *
   * @returns {IDictionary<JsonApi.IRelationship>} Record relationship links
   *
   * @memberOf Record
   */
  public getRelationshipLinks(): IDictionary<JsonApi.IRelationship> {
    return this.__internal && this.__internal.relationships;
  }

  /**
   * Fetch a relationship link
   *
   * @param {string} relationship Name of the relationship
   * @param {string} name Name of the link
   * @param {IRequestOptions} [options] Server options
   * @param {boolean} [force=false] Ignore the existing cache
   * @returns {Promise<Response>} Response promise
   *
   * @memberOf Record
   */
  public fetchRelationshipLink(
    relationship: string,
    name: string,
    options?: IRequestOptions,
    force: boolean = false,
  ): Promise<Response> {
    this.__relationshipLinkCache[relationship] = this.__relationshipLinkCache[relationship] || {};

    /* istanbul ignore else */
    if (!(name in this.__relationshipLinkCache) || force) {
      const link: JsonApi.ILink = (
        'relationships' in this.__internal &&
        relationship in this.__internal.relationships &&
        name in this.__internal.relationships[relationship]
      ) ? this.__internal.relationships[relationship][name] : null;
      const headers: IDictionary<string> = options && options.headers;

      this.__relationshipLinkCache[relationship][name] = fetchLink(link, this.__collection as Store, headers, options);
    }

    return this.__relationshipLinkCache[relationship][name];
  }

  /**
   * Get record metadata
   *
   * @returns {object} Record metadata
   *
   * @memberOf Record
   */
  public getMeta(): object {
    return this.__internal && this.__internal.meta;
  }

  /**
   * Get record links
   *
   * @returns {IDictionary<JsonApi.ILink>} Record links
   *
   * @memberOf Record
   */
  public getLinks(): IDictionary<JsonApi.ILink> {
    return this.__internal && this.__internal.links;
  }

  /**
   * Fetch a record link
   *
   * @param {string} name Name of the link
   * @param {IRequestOptions} [options] Server options
   * @param {boolean} [force=false] Ignore the existing cache
   * @returns {Promise<Response>} Response promise
   *
   * @memberOf Record
   */
  public fetchLink(name: string, options?: IRequestOptions, force: boolean = false): Promise<Response> {
    if (!(name in this.__linkCache) || force) {
      const link: JsonApi.ILink = ('links' in this.__internal && name in this.__internal.links) ?
        this.__internal.links[name] : null;
      this.__linkCache[name] = fetchLink(link, this.__collection as Store, options && options.headers, options);
    }

    let request: Promise<Response> = this.__linkCache[name];

    if (this['__queue__']) {
      request = this.__linkCache[name].then((response) => {
        const related: Record = this['__related__'];
        const prop: string = this['__prop__'];
        const record: Record = response.data as Record;
        if (record &&
          record.getRecordType() !== this.getRecordType() &&
          record.getRecordType() === related.getRecordType()
        ) {

          /* istanbul ignore if */
          if (prop) {
            related[prop] = record;
            return response;
          }
          related.__persisted = true;
          return response.replaceData(related);
        }
        return response;
      });
    }

    return request;
  }

  /**
   * Get the persisted state
   *
   * @readonly
   * @private
   * @type {boolean}
   * @memberOf Record
   */
  private get __persisted(): boolean {
    return (this.__internal && this.__internal.persisted) || false;
  }

  /**
   * Set the persisted state
   *
   * @private
   *
   * @memberOf Record
   */
  private set __persisted(state: boolean) {
    this.__internal.persisted = state;
  }

  /**
   * Serialize the record into JSON API format
   *
   * @returns {JsonApi.IRecord} JSON API formated record
   *
   * @memberOf Record
   */
  public toJsonApi(options?: IJsonApiOptions): JsonApi.IRecord {
    const attributes: IDictionary<any> = this.toJS();

    const useAutogenerated: boolean = this.static['useAutogeneratedIds'];
    const data: JsonApi.IRecord = {
      attributes,
      id: (this.__persisted || useAutogenerated) ? this.getRecordId() : undefined,
      type: this.getRecordType() as string,
    };

    const includeRefs = (options && options.include) || [];
    const refs: IDictionary<string> = this['__refs'];
    objectForEach(refs, (key: string) => {
      if (includeRefs.indexOf(key) < 0) { return; }

      data.relationships = data.relationships || {};
      const rel = mapItems(this[`${key}Id`], (id: number|string) => {
        if (!id && id !== 0) {
          return null;
        }
        return {id, type: refs[key]};
      });
      data.relationships[key] = {data: rel} as JsonApi.IRelationship;

      delete data.attributes[key];
      delete data.attributes[`${key}Id`];
      delete data.attributes[`${key}Meta`];
    });

    delete data.attributes.__internal;
    delete data.attributes.__type__;

    return data;
  }

  /**
   * Saves (creates or updates) the record to the server
   *
   * @param {IRequestOptions} [options] Server options
   * @param {boolean} [ignoreSelf=false] Should the self link be ignored if it exists
   * @returns {Promise<Record>} Returns the record is successful or rejects with an error
   *
   * @memberOf Record
   */
  public save(options: IRequestOptions = {}, ignoreSelf: boolean = false): Promise<Record> {
    const store: Store = this.__collection as Store;
    const { include, fields } = options;
    const data: JsonApi.IRecord = this.toJsonApi({ include, fields });
    const requestMethod: Function = this.__persisted ? update : create;
    return requestMethod(store, this.__getUrl(options, ignoreSelf), {data}, options && options.headers)
      .then(handleResponse(this));
  }

  public saveRelationship(relationship: string, options?: IRequestOptions): Promise<Record> {
    const href = this.__getRelationshipUrl(relationship, options);
    const store: Store = this.__collection as Store;

    const type: string = this['__refs'][relationship];
    type ID = JsonApi.IIdentifier|Array<JsonApi.IIdentifier>|null;
    const relId = this[`${relationship}Id`];
    const data: ID = relId === undefined || relId === null ?
      null :
      mapItems(relId, (id) => ({id, type})) as ID;

    return update(store, href, {data}, options && options.headers)
      .then(handleResponse(this, relationship));
  }

  /**
   * Remove the records from the server and store
   *
   * @param {IRequestOptions} [options] Server options
   * @param {boolean} [ignoreSelf=false] Should the self link be ignored if it exists
   * @returns {Promise<boolean>} Resolves true if successfull or rejects if there was an error
   *
   * @memberOf Record
   */
  public remove(options?: IRequestOptions, ignoreSelf: boolean = false): Promise<boolean> {
    const store: Store = this.__collection as Store;
    if (!this.__persisted) {
      this.__collection.remove(this.getRecordType(), this.getRecordId());
      return Promise.resolve(true);
    }
    return remove(store, this.__getUrl(options, ignoreSelf), options && options.headers)
      .then((response: Response) => {

        /* istanbul ignore if */
        if (response.error) {
          throw response.error;
        }

        this.__persisted = false;

        if (this.__collection) {
          this.__collection.remove(this.getRecordType(), this.getRecordId());
        }

        return true;
      });
  }

  /**
   * Set the persisted status of the record
   *
   * @param {boolean} state Is the record persisted on the server
   *
   * @memberOf Record
   */
  public setPersisted(state: boolean): void {
    this.__persisted = state;
  }

  /**
   * Get the URL that should be used for the API calls
   *
   * @private
   * @returns {string} API URL
   *
   * @memberOf Record
   */
  private __getUrl(options?: IRequestOptions, ignoreSelf?: boolean): string {

    const links: IDictionary<JsonApi.ILink> = this.getLinks();
    if (!ignoreSelf && links && links.self) {
      const self: JsonApi.ILink = links.self;

      /* istanbul ignore next */
      return typeof self === 'string' ? self : self.href;
    }

    /* istanbul ignore next */
    const type = getValue<string>(this.static.endpoint) || this.getRecordType() || this.static.type;

    return buildUrl(type, this.__persisted ? this.getRecordId() : null, null, options);
  }

  private __getRelationshipUrl(relationship: string, options?: IRequestOptions): string {
    const link: JsonApi.ILink = (
      'relationships' in this.__internal &&
      relationship in this.__internal.relationships &&
      'self' in this.__internal.relationships[relationship]
    ) ? this.__internal.relationships[relationship]['self'] : null;

    if (link) {
      return typeof link === 'object' ? link.href : link;
    } else {
      return buildRelationshipUrl(
        this.getRecordType(),
        this.getRecordId(),
        relationship,
        null,
        options,
      );
    }
  }
}
